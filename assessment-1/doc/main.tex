\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{courier}
\usepackage{fancyhdr}

\pagestyle{fancy}
\title{Parallel Design Patterns 1}
\author{B138813}
\date{February 2019}

\begin{document}
\lhead{Parallel Design Patterns I}
\rhead{B138813}
\noindent\textbf{1(a).} \newline

The first pattern we recommend for this problem is the \textbf{Actor Pattern}. We make this suggestion as the problem domain can be expressed as entities, which map, on a 1:1 basis, to actors. These actors are squirrels, grid cells and simulation master. Squirrels and grid cells have a one to one mapping with the functionality described in the details of the biologists model, i.e. a grid cell will have a populationInflux value. This mapping is a notable advantage as it will make it much easier for biologists to understand the final code. We also have to opportunity to reuse the biologist's function to map the x,y location of a squirrel to a grid cell number, and make that grid cell number the rank of the grid process in an MPI implementation. The squirrel master would be able to act both as a clock, to instruct grid cells if a two or three month interval had passed, which would then adjust the populationInflux and infectionLevel of all land cells. The simulation master could also keep a list of live and dead squirrels, to ensure that no more than 200 squirrels are created, and to terminate the program if all squirrels die or the simulation time has elapsed. When a squirrel is born, the simulation master can simply resurrect a squirrel to be reused. Another key advantage of this model is its extensiblity, in that if the biologists wish to create a predator animal for the simulation, they only need to create another actor, rather than restructuring and rethinking their entire code base.

However, that is not to say there are not drawbacks to the actor pattern for this problem domain. It is very difficult to design any form of locality in the actor pattern, which means that squirrel processes may communicate with grid processes very far away from themselves, leading to latency. For this model, the number of cells is 16 and the maximum number of squirrels is 200, so data locality isn't too much of a priority, but it may become more of an issue at large scales. It is noteworthy that the actor pattern can be very difficult to debug, as squirrels and land cells will interact in a way that inevitably becomes harder and harder to determine as the simulation continues. Whilst this unpredictability does closely follow the biologist's model, it will make the simulation difficult to debug.

We also recommend the use of \textbf{Geometric Decomposition} with halo swapping for this problem. We make this suggestion because we principally believe that a geometric decomposition allows us to fully exploit the local nature of the problem. Each grid square would essentially be equivalent to a land cell, with all the values and functions as in the actor pattern. However, in the Geometric Decomposition we would bundle these functions along with other functions in a general \texttt{process()} function, which would also move squirrels between grid squares and manage squirrel mortality. Squirrels would be represented by data strucutres, which would be passed around grid squares. Halo swaps could be employed to pass squirrels across the borders of each UE's grid squares. Each UE could manage its own grid \newline

\noindent\textbf{1(b).} \newline
Pipeline pattern bad because you can't get a sense of global time

\end{document}
%
